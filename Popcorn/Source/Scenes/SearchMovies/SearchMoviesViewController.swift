//
//  SearchMoviesViewController.swift
//  Popcorn
//
//  Created by Hashem Aboonajmi on 3/29/18.
//  Copyright (c) 2018 Hashem Aboonajmi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import AsyncDisplayKit
import Async

private enum SearchMoviesState
{
    case `default`, loading, loaded(movies: [SearchMovies.Search.ViewModel.DisplayMovie]), error(reason: SearchMovies.SearchFailure.ViewModel.Reason)
}

protocol SearchMoviesDisplayLogic: class
{
    func displaySearchedMovies(viewModel: SearchMovies.Search.ViewModel)
    func displaySearchFailure(viewModel: SearchMovies.SearchFailure.ViewModel)
    func displaySearchStarted()
    func displayRecentSearches(viewModel: SearchMovies.FetchRecentSearches.ViewModel)
}

class SearchMoviesViewController: ASViewController<ASDisplayNode>, SearchMoviesDisplayLogic
{
    var interactor: SearchMoviesBusinessLogic?
    var router: (NSObjectProtocol & SearchMoviesRoutingLogic & SearchMoviesDataPassing)?
    
    // set a type alias for DisplayMovie to reduce verbosity
    typealias Movie = SearchMovies.Search.ViewModel.DisplayMovie
    
    
    // By initializing UISearchController with a nil value for the searchResultsController, you tell the search controller that you want use the same view you’re searching to display the results
    let searchController = UISearchController(searchResultsController: nil)
    
    let collectionNode: ASCollectionNode
    var statusNode: StatusNode?
    let suggestionsNode = SuggestionsNode()
    
    let dataSource = SearchMoviesDataSource()
    private var initialSafeAreaInsetTop: CGFloat = 0
    
    // MARK: Object lifecycle
    
    init()
    {
        
        let layout = UICollectionViewFlowLayout()
        layout.minimumLineSpacing = 0
        
        collectionNode = ASCollectionNode(collectionViewLayout: layout)
        
        let displayNode = ASDisplayNode()
        displayNode.addSubnode(collectionNode)
        
        super.init(node: displayNode)
        setup()
        
        // set collectionNode delegate and dataSource
        collectionNode.delegate = self
        collectionNode.dataSource = dataSource
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = SearchMoviesInteractor()
        let presenter = SearchMoviesPresenter()
        let router = SearchMoviesRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        customizeUI()
        setupSearchController()
        
        state = .default
    }
    
    // The following makes the scroll bar visible at first, then allows it to hide when scrolling:
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        navigationItem.hidesSearchBarWhenScrolling = false
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        navigationItem.hidesSearchBarWhenScrolling = true
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        collectionNode.frame = view.bounds
    }
    
    override func viewSafeAreaInsetsDidChange() {
        super.viewSafeAreaInsetsDidChange()
        if initialSafeAreaInsetTop == 0 {
            initialSafeAreaInsetTop = view.safeAreaInsets.top
        }
    }
    
    // MARK: UI Customiziation
    
    func customizeUI()
    {
        // make collectionNode always bounce vertically
        collectionNode.view.alwaysBounceVertical = true
        // by default collectionNode is hidden
        collectionNode.isHidden = true
        // hide keyboard while scrolling
        collectionNode.view.keyboardDismissMode = .interactive
        
        // set backgroundColor. default is black
        node.backgroundColor = .white
        
        // customize navigationBar
        title = "Popcorn"
        // display large title in navigationBar
        navigationController?.navigationBar.prefersLargeTitles = true
    }
    
    // MARK: Setup UISearchController
    
    func setupSearchController()
    {
        // by default searchController obscure the view it is presented over, because we use the current view to display result, so we disbale it
        searchController.obscuresBackgroundDuringPresentation = false
        
        // set searchBar delegate to self. we want to know when user has pressed the search button to init search request
        searchController.searchBar.delegate = self
        
        // set searchBar placeholder
        searchController.searchBar.placeholder = "Search Movies"
        
        // add search bar to navigationItem by assigning searchController to navigationItem searchController property
        navigationItem.searchController = searchController
    }
    
    // MARK: Search Movies
    
    func search(withSearchTerm term: String)
    {
        let request = SearchMovies.Search.Request(searchTerm: term)
        interactor?.searchMovies(request: request)
    }
    
    var context: ASBatchContext?
    func requestNextPage(_ context: ASBatchContext)
    {
        self.context = context
        interactor?.fetchNextPage()
    }
    
    // MARK: Display Logic
    
    func displaySearchStarted()
    {
        state = .loading
    }
    
    func displaySearchedMovies(viewModel: SearchMovies.Search.ViewModel)
    {
        state = .loaded(movies: viewModel.displayedMovies)
    }
    
    func displaySearchFailure(viewModel: SearchMovies.SearchFailure.ViewModel)
    {
        state = .error(reason: viewModel.reason)
    }
    
    func displayRecentSearches(viewModel: SearchMovies.FetchRecentSearches.ViewModel)
    {
        show(recentSearches: viewModel.recentSearches)
    }
    
    // MARK: States
    
    fileprivate var state: SearchMoviesState = .default {
        didSet {
            switch state {
            case .default:
                
                let status = StatusModel(title: "Search your favorites movies", image: #imageLiteral(resourceName: "logo"))
                show(status: status)
                
                //  if collectionNode contentSize height is less than view height and we hit cancel button in the search bar, collectionNode doesn't move to corrct offset
                if collectionNode.view.contentSize.height > view.height {
                    collectionNode.setContentOffset(CGPoint(x: 0, y: -initialSafeAreaInsetTop), animated: true)
                }
                
                // cancel any pending search
                interactor?.cancelSearch()
                
            case .loading:
                
                // hide suggestions node, if visible
                hideSuggestions()
                
                // hide status node, if visible
                statusNode?.removeFromSupernode()
                collectionNode.isHidden = false
                clearAllRows()
                
            case .loaded(let movies):
                
                insertNewRows(movies)
                
                // completeBatchFetching must be called with value of true to recieve future batch fetching request calls
                context?.completeBatchFetching(true)
                
            case .error(let reason):
                context?.cancelBatchFetching()
                
                switch reason {
                case .noConnection:
                    
                    let status = StatusModel(title: "Please connect to the internet", image: #imageLiteral(resourceName: "warning"), actionTitle: "Settings") {
                        UIApplication.openSettings()
                    }
                    show(status: status)
                    
                case .error(let message):
                    print(message)
                    
                    let status = StatusModel(title: "Oops! an error occured", image: #imageLiteral(resourceName: "warning"), actionTitle: "Retry") { [unowned self] in
                        self.startSearch()
                    }
                    show(status: status)
                }
            }
        }
    }
    
    fileprivate func insertNewRows(_ newItems: [Movie]){
        
        if newItems.isEmpty {
            if let deletedSectionIndex = dataSource.deleteSection(.activityIndicator)
            {
                collectionNode.deleteSections(IndexSet(integer: deletedSectionIndex))
            }
        }
        
        // update data source
        let insertedItemsIndexPaths = dataSource.insertNewItems(newItems)
        
        if dataSource.isEmpty {
            // no result found
            let searchTerm = searchController.searchBar.text!
            let status = StatusModel(title: "Oops! we couldn’t find “\(searchTerm)”", image: #imageLiteral(resourceName: "sad"))
            show(status: status)
            
        } else {
            
            collectionNode.insertItems(at: insertedItemsIndexPaths)
        }
    }
    
    fileprivate func clearAllRows()
    {
        dataSource.clear()
        // this function must called on the main thread
        Async.main {
            self.collectionNode.reloadData()
        }
    }
    
    // MARK: Helper
    
    func searchBarIsEmpty() -> Bool {
        return searchController.searchBar.text?.isEmpty ?? true
    }
    
    func show(status: StatusModel)
    {
        let statusNode = StatusNode(status: status)
        statusNode.frame = node.frame
        
        // clear old status if it is displaying
        self.statusNode?.removeFromSupernode()
        // display new status
        node.addSubnode(statusNode)
        
        self.statusNode = statusNode
        
    }
    
    fileprivate func show(recentSearches searches: [String])
    {
        // assign recent searches to suggestionNode
        suggestionsNode.suggestions = searches
        
        // set frame and position of suggestionsNode
        let topInset = view.safeAreaInsets.top
        suggestionsNode.frame = view.bounds
        suggestionsNode.top = topInset
        
        // suggestionsNode should initially be hidden
        suggestionsNode.alpha = 0
        node.addSubnode(suggestionsNode)
        
        // by tapping on a search term, a new search request will trigger
        suggestionsNode.onItemSelection = { [unowned self] searchTerm in
            
            self.searchController.searchBar.text = searchTerm
            self.searchController.searchBar.resignFirstResponder()
            self.search(withSearchTerm: searchTerm)
        }
        
        if let transitionCoordinator = searchController.transitionCoordinator
        {
            // animate suggestionsNode alognside searchController transition
            transitionCoordinator.animate(alongsideTransition: { [unowned self] context in
                let statusBarHeight = UIApplication.shared.statusBarFrame.height
                let searchBarHeight = self.searchController.searchBar.height
                self.suggestionsNode.alpha = 1
                self.suggestionsNode.top = statusBarHeight + searchBarHeight
                }, completion: nil)
        } else {
            
            // if transitionCoordinator is nil means searchController is already presented. so we display suggestionsNode with a basic animation
            UIView.animate(withDuration: 0.2, animations: {
                self.suggestionsNode.alpha = 1
            })
        }
       
    }
    
    fileprivate func hideSuggestions()
    {
        // we start hiding suggestionNode after the next run loop
        // because initially transitionCoordinator is nil
        Async.main {
            if let transitionCoordinator = self.searchController.transitionCoordinator {
                // animate suggestionsNode alognside searchController transition
                transitionCoordinator.animate(alongsideTransition: { context in
                    self.suggestionsNode.alpha = 0
                    self.suggestionsNode.top = self.initialSafeAreaInsetTop
                }, completion: { _ in
                    self.suggestionsNode.removeFromSupernode()
                })
                
            } else {
                
                // if transitionCoordinator after next runloop is still nil, we should hide it with basic animation
                UIView.animate(withDuration: 0.2, animations: {
                    self.suggestionsNode.alpha = 0
                }, completion: { _ in
                    self.suggestionsNode.removeFromSupernode()
                })
            }
        }
    }
}

extension SearchMoviesViewController: ASCollectionDelegateFlowLayout
{
    func collectionNode(_ collectionNode: ASCollectionNode, constrainedSizeForItemAt indexPath: IndexPath) -> ASSizeRange {
        
        // set a flexible size to cells
        return ASSizeRangeMake(CGSize(width: node.width, height: 0), CGSize(width: node.width, height: 500))
    }
    
    /// Receive a message that the collection node is near the end of its data set and more data should be fetched if
    /// this method is called in the background thread
    
    func collectionNode(_ collectionNode: ASCollectionNode, willBeginBatchFetchWith context: ASBatchContext) {
        
        context.beginBatchFetching()
        self.requestNextPage(context)
    }
    
    /// Tell the collection node if batch fetching should begin
    
    func shouldBatchFetch(for collectionNode: ASCollectionNode) -> Bool {
        
        switch state {
        case .loaded(_):
            return searchBarIsEmpty() == false 
        default:
            return false
        }
    }
}

extension SearchMoviesViewController: UISearchBarDelegate
{
    
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String)
    {
        if searchBarIsEmpty() {
            interactor?.fetchRecentSearches()
        }
    }
    
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        interactor?.fetchRecentSearches()
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        startSearch()
    }
    
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        state = .default
        hideSuggestions()
    }
    
    func startSearch()
    {
        // hide keyboard, if visible
        self.view.endEditing(true)
        
        // after a complete search paging, activityIndicator section will be removed to indicate user scrolled all the search results. for new search is this section is removed we appened it again
        if dataSource.hasSection(.activityIndicator) == false {
            dataSource.insertSection(.activityIndicator)
        }
        
        let searchBar = searchController.searchBar
        
        if searchBarIsEmpty() == false {
            search(withSearchTerm: searchBar.text!)
        }
    }
}



