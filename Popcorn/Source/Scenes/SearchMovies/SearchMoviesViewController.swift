//
//  SearchMoviesViewController.swift
//  Popcorn
//
//  Created by Hashem Aboonajmi on 3/29/18.
//  Copyright (c) 2018 Hashem Aboonajmi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import AsyncDisplayKit
import Async

private enum SearchMoviesState
{
    case `default`, loading, loaded(movies: [SearchMovies.Search.ViewModel.DisplayMovie]), error(reason: SearchMovies.SearchFailure.ViewModel.Reason)
}

protocol SearchMoviesDisplayLogic: class
{
    func displaySearchedMovies(viewModel: SearchMovies.Search.ViewModel)
    func displaySearchFailure(viewModel: SearchMovies.SearchFailure.ViewModel)
    func displaySearchStarted()
}

class SearchMoviesViewController: ASViewController<ASDisplayNode>, SearchMoviesDisplayLogic
{
    var interactor: SearchMoviesBusinessLogic?
    var router: (NSObjectProtocol & SearchMoviesRoutingLogic & SearchMoviesDataPassing)?
    
    // set a type alias for DisplayMovie to reduce verbosity
    typealias Movie = SearchMovies.Search.ViewModel.DisplayMovie
    var displayedMovies = [Movie]()
    
    // at first there is no section. view only displays a search bar.
    var sections : [SearchMovies.Section] = [.movies, .activityIndicator]
    
    // By initializing UISearchController with a nil value for the searchResultsController, you tell the search controller that you want use the same view you’re searching to display the results
    let searchController = UISearchController(searchResultsController: nil)
    
    let collectionNode: ASCollectionNode
    var statusNode: StatusNode?
    
    // MARK: Object lifecycle
    
    init()
    {
        
        let layout = UICollectionViewFlowLayout()
        layout.minimumLineSpacing = 0
        
        collectionNode = ASCollectionNode(collectionViewLayout: layout)
        
        let displayNode = ASDisplayNode()
        displayNode.addSubnode(collectionNode)
        
        super.init(node: displayNode)
        setup()
        
        // set collectionNode delegate and dataSource
        collectionNode.delegate = self
        collectionNode.dataSource = self
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = SearchMoviesInteractor()
        let presenter = SearchMoviesPresenter()
        let router = SearchMoviesRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        customizeUI()
        setupSearchController()
        
        state = .default
    }
    
    // The following makes the scroll bar visible at first, then allows it to hide when scrolling:
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        navigationItem.hidesSearchBarWhenScrolling = false
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        navigationItem.hidesSearchBarWhenScrolling = true
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        collectionNode.frame = view.bounds
    }
    // MARK: UI Customiziation
    
    func customizeUI()
    {
        // make collectionNode always bounce vertically
        collectionNode.view.alwaysBounceVertical = true
        // by default collectionNode is hidden
        collectionNode.isHidden = true
        // hide keyboard while scrolling
        collectionNode.view.keyboardDismissMode = .interactive
        
        // set backgroundColor. default is black
        node.backgroundColor = .white
        
        // customize navigationBar
        title = "Popcorn"
        // display large title in navigationBar
        navigationController?.navigationBar.prefersLargeTitles = true
    }
    
    // MARK: Setup UISearchController
    
    func setupSearchController()
    {

        // by default searchController obscure the view it is presented over, because we use the current view to display result, so we disbale it
        searchController.obscuresBackgroundDuringPresentation = false
        
        // set searchBar delegate to self. we want to know when user has pressed the search button to init search request
        searchController.searchBar.delegate = self
        
        // set searchBar placeholder
        searchController.searchBar.placeholder = "Search Movies"
        
        // add search bar to navigationItem by assigning searchController to navigationItem searchController property
        navigationItem.searchController = searchController
    }
    
    // MARK: Search Movies
    
    func search(withSearchTerm term: String)
    {
        let request = SearchMovies.Search.Request(searchTerm: term)
        interactor?.searchMovies(request: request)
    }
    
    var context: ASBatchContext?
    func requestNextPage(_ context: ASBatchContext)
    {
        self.context = context
        interactor?.fetchNextPage()
    }
    
    // MARK: Display Logic
    
    func displaySearchStarted()
    {
        state = .loading
    }
    
    func displaySearchedMovies(viewModel: SearchMovies.Search.ViewModel)
    {
        state = .loaded(movies: viewModel.displayedMovies)
    }
    
    func displaySearchFailure(viewModel: SearchMovies.SearchFailure.ViewModel)
    {
        state = .error(reason: viewModel.reason)
    }
    
    // MARK: States
    
    fileprivate var state: SearchMoviesState = .default {
        didSet {
            switch state {
            case .default:
                
                let status = StatusModel(title: "Search your favorites movies", image: #imageLiteral(resourceName: "logo"))
                show(status: status)
                
            case .loading:
                
                statusNode?.removeFromSupernode()
                collectionNode.isHidden = false
                clearAllRows()
                
            case .loaded(let movies):
                
                insertNewRows(movies)
                
                // completeBatchFetching must be called with value of true to recieve future batch fetching request calls
                context?.completeBatchFetching(true)
                
            case .error(let reason):
                context?.cancelBatchFetching()
                
                switch reason {
                case .noConnection:
                    
                    let status = StatusModel(title: "Please connect to the internet", image: #imageLiteral(resourceName: "warning"), actionTitle: "Settings") {
                        UIApplication.openSettings()
                    }
                    show(status: status)
                    
                case .error(let message):
                    print(message)
                    // hide keyboard, if visible
                    self.view.endEditing(true)
                    
                    let status = StatusModel(title: "Oops! an error occured", image: #imageLiteral(resourceName: "warning"), actionTitle: "Retry") { [unowned self] in
                        self.startSearch()
                    }
                    show(status: status)
                }
            }
        }
    }
    
    fileprivate func insertNewRows(_ newItems: [Movie]){
        
        if newItems.isEmpty {
            if let loadingSection = sections.index(of: .activityIndicator) {
                sections.remove(at: loadingSection)
                collectionNode.deleteSections(IndexSet(integer: loadingSection))
            }
        }
        
        // update data source
        displayedMovies.append(contentsOf: newItems)
        
        if displayedMovies.isEmpty {
            // no result found
            let searchTerm = searchController.searchBar.text!
            let status = StatusModel(title: "Oops! we couldn’t find “\(searchTerm)”", image: #imageLiteral(resourceName: "sad"))
            show(status: status)
            
        } else {
            var indexPaths = [IndexPath]()
            let itemsCount = displayedMovies.count
            for row in itemsCount - newItems.count ..< itemsCount {
                let indexPath = IndexPath(row: row, section: 0)
                indexPaths.append(indexPath)
            }
            
            collectionNode.insertItems(at: indexPaths)
        }
    }
    
    fileprivate func clearAllRows()
    {
        displayedMovies.removeAll()
        Async.main {
            self.collectionNode.reloadData()
        }
    }
    
    // MARK: Helper
    
    func searchBarIsEmpty() -> Bool {
        return searchController.searchBar.text?.isEmpty ?? true
    }
    
    func show(status: StatusModel)
    {
        let statusNode = StatusNode(status: status)
        statusNode.frame = node.frame
        
        // clear old status if it is displaying
        self.statusNode?.removeFromSupernode()
        // display new status
        node.addSubnode(statusNode)
        
        self.statusNode = statusNode
    }
}

extension SearchMoviesViewController: ASCollectionDataSource
{
    func numberOfSections(in collectionNode: ASCollectionNode) -> Int {
        return sections.count
    }
    
    func collectionNode(_ collectionNode: ASCollectionNode, numberOfItemsInSection section: Int) -> Int {
        switch section {
        case 0:
            return displayedMovies.count
        case 1:
            return 1
        default:
            return 0
        }
    }
    
    func collectionNode(_ collectionNode: ASCollectionNode, nodeBlockForItemAt indexPath: IndexPath) -> ASCellNodeBlock {
        let row = indexPath.row
        let section = indexPath.section
        
        return { [weak self] in
            
            guard let `self` = self else {
                return ASCellNode()
            }
            
            if section == 0 {
                
                let movie = self.displayedMovies[row]
                return MovieNode(movie: movie)
                
            } else {
                return LoadingCell()
            }
        }
    }
}

extension SearchMoviesViewController: ASCollectionDelegateFlowLayout
{
    func collectionNode(_ collectionNode: ASCollectionNode, constrainedSizeForItemAt indexPath: IndexPath) -> ASSizeRange {
        
        // set a flexible size to cells
        return ASSizeRangeMake(CGSize(width: node.width, height: 0), CGSize(width: node.width, height: 500))
    }
    
    /// Receive a message that the collection node is near the end of its data set and more data should be fetched if
    /// this method is called in the background thread
    
    func collectionNode(_ collectionNode: ASCollectionNode, willBeginBatchFetchWith context: ASBatchContext) {
        
        context.beginBatchFetching()
        self.requestNextPage(context)
    }
    
    /// Tell the collection node if batch fetching should begin
    
    func shouldBatchFetch(for collectionNode: ASCollectionNode) -> Bool {
        switch state {
        case .loaded(_):
            return true
        default:
            return false
        }
    }
}

extension SearchMoviesViewController: UISearchBarDelegate
{
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        startSearch()
    }
    
    func startSearch()
    {
        // after a complete search paging, activityIndicator section will be removed to indicate user scrolled all the search results. for new search is this section is removed we appened it again
        if sections.index(of: .activityIndicator) == nil {
            sections.append(.activityIndicator)
        }
        
        let searchBar = searchController.searchBar
        
        if searchBarIsEmpty() == false {
            search(withSearchTerm: searchBar.text!)
        }
    }
}



